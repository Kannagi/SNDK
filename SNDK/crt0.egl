
SNES_BANK 0
//error

proc SNES_ERROR:
{
	spm uint16 tdebug1,tdebug2,tdebug3,tdebug4;
	spm uint16 reg1,reg2,reg3;
	uint16 debug1,debug2
	
	asm "plx";
	tdebug4 = idx;
	asm "phx";
	MODE16
	reg1 = acc;
	reg2 = idx;
	reg3 = idy;
	
	MODE8
	
	call SNDK_PrintHexa16: reg1,2,8,SNDK_FONTPAL0;
	call SNDK_PrintHexa16: reg2,2,9,SNDK_FONTPAL0;
	call SNDK_PrintHexa16: reg3,2,10,SNDK_FONTPAL0;
	
	call SNDK_PrintHexa16: tdebug1,2,11,SNDK_FONTPAL0;
	call SNDK_PrintHexa16: tdebug2,2,12,SNDK_FONTPAL0;
	call SNDK_PrintHexa16: tdebug3,2,13,SNDK_FONTPAL0;
	call SNDK_PrintHexa16: tdebug4,2,14,SNDK_FONTPAL0;
		
	asm "rti";
}



proc SNES_IRQHV:
{
	uint8 bgmode
	asm "php"
	asm "pha"
	
	if bgmode != 0
	{
		BGMODE = bgmode
	}
	
	asm "pla"
	asm "plp"
	asm "rti";
}

proc _start:;
{
	asm "
	sei
	cld
	clc
	xce

	rep #$30
	ldx #$01F8
	txs
	
	phk
	pld
	lda #0
	tcd

	sep #$20
	
	;fastrom
	jml _start_jump
	_start_jump:
";
	NMITIMEN  = 0x00; //Disable all
	INIDISP = 0x80; //Forced Blank
	MEMSEL = 1; //mode 3.58 MHz
	
	call SNDK_Init:;
	
	jump main:
	
	jump _start:
}

func SNDK_Joypad:;
{
	uint8 joya,joyb;
	
	acc = JOYSER0;
	joya = acc;
	if acc == 0
	{
		return;
	}
	
	acc = JOYSER1;
	joyb = acc;
	if acc == 0
	{
		return;
	}
	
	
	uint8 pad1l,pad1h,pad2l,pad2h;
	uint8 pad3l,pad3h,pad4l,pad4h;
	
	uint8 npad1l,npad1h,npad2l,npad2h;
	uint8 npad3l,npad3h,npad4l,npad4h;
	
	uint8 epad1l,epad1h,epad2l,epad2h;
	uint8 epad3l,epad3h,epad4l,epad4h;
	
	MODE16

	//PAD1
	acc = pad1l ^ 0xFFFF
	npad1l = acc &STDCONTROL1L;
	
	acc = STDCONTROL1L^pad1l
	epad1l = acc^npad1l;
	
	pad1l = STDCONTROL1L
	
	//PAD2
	acc = pad2l ^ 0xFFFF
	npad2l = acc &STDCONTROL2L;
	
	acc = STDCONTROL2L^pad2l
	epad2l = acc^npad2l;
	
	pad2l = STDCONTROL2L
	
	
	
	pad2l = STDCONTROL2L;
	pad3l = STDCONTROL3L;
	pad4l = STDCONTROL4L;
	
	MODE8
	/*

	
	pad1l =? STDCONTROL1L;
	pad2l =? STDCONTROL2L;
	pad3l =? STDCONTROL3L;
	pad4l =? STDCONTROL4L;
	/*
	pad1h = STDCONTROL1H;
	pad2h = STDCONTROL2H;
	pad3h = STDCONTROL3H;
	pad4h = STDCONTROL4H;
	*/
}

proc VBlank:
{
	asm "
		jml FastVBlank
FastVBlank:
";
	uint8 enable,wait;
	uint16 time;
	
	acc  = RDNMI;
	
	INIDISP = 0x80 | SNDK_Light;
	call SNDK_VBlank:
	
	do
	{
		
	}
	while HVBJOY & 0x01
	call SNDK_Joypad:
	
	idy = 0;
	if wait == 0
	{
		do
		{
			idy+=1;
		}
		while HVBJOY & 0x80
	}
	time = idy;
	
	//SNDK_SendVRAM 0x4000,DATA_FONT_SNDK_S,0xAB0
	INIDISP = SNDK_Light;
	
	acc = 0;
	asm "rti";
}

LUT_ANGLE:
.data.b 0x00,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,
.data.b 0xf0,0xff,0x7f,0x5f,0x3f,0x3f,0x2f,0x2f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,
.data.b 0xf0,0xf7,0xff,0xaf,0x7f,0x6f,0x5f,0x4f,0x3f,0x3f,0x3f,0x2f,0x2f,0x2f,0x2f,0x2f,
.data.b 0xf0,0xf5,0xfa,0xff,0xbf,0x9f,0x7f,0x6f,0x5f,0x5f,0x4f,0x4f,0x3f,0x3f,0x3f,0x3f,
.data.b 0xf0,0xf3,0xf7,0xfb,0xff,0xcf,0xaf,0x8f,0x7f,0x6f,0x6f,0x5f,0x5f,0x4f,0x4f,0x4f,
.data.b 0xf0,0xf3,0xf6,0xf9,0xfc,0xff,0xcf,0xaf,0x9f,0x8f,0x7f,0x6f,0x6f,0x5f,0x5f,0x5f,
.data.b 0xf0,0xf2,0xf5,0xf7,0xfa,0xfc,0xff,0xcf,0xbf,0xaf,0x9f,0x8f,0x7f,0x6f,0x6f,0x6f,
.data.b 0xf0,0xf2,0xf4,0xf6,0xf8,0xfa,0xfc,0xff,0xdf,0xbf,0xaf,0x9f,0x8f,0x8f,0x7f,0x7f,
.data.b 0xf0,0xf1,0xf3,0xf5,0xf7,0xf9,0xfb,0xfd,0xff,0xdf,0xcf,0xaf,0xaf,0x9f,0x8f,0x8f,
.data.b 0xf0,0xf1,0xf3,0xf5,0xf6,0xf8,0xfa,0xfb,0xfd,0xff,0xdf,0xcf,0xbf,0xaf,0x9f,0x9f,
.data.b 0xf0,0xf1,0xf3,0xf4,0xf6,0xf7,0xf9,0xfa,0xfc,0xfd,0xff,0xdf,0xcf,0xbf,0xaf,0xaf,
.data.b 0xf0,0xf1,0xf2,0xf4,0xf5,0xf6,0xf8,0xf9,0xfa,0xfc,0xfd,0xff,0xdf,0xcf,0xbf,0xbf,
.data.b 0xf0,0xf1,0xf2,0xf3,0xf5,0xf6,0xf7,0xf8,0xfa,0xfb,0xfc,0xfd,0xff,0xdf,0xcf,0xcf,
.data.b 0xf0,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf8,0xf9,0xfa,0xfb,0xfc,0xfd,0xff,0xdf,0xdf,
.data.b 0xf0,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,0xf9,0xfa,0xfb,0xfc,0xfd,0xff,0xef,
.data.b 0xf0,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,0xf9,0xfa,0xfb,0xfc,0xfd,0xfe,0xff,

/*
proc VBlank:;
{
	asm "
		jml FastVBlank
FastVBlank:
	phd
	php
	
	phb
	pha
	phx
	phy
	
	sep #$20
";
	uint8 enable,wait;
	uint16 time;
	
	acc  = RDNMI;
	
	if enable == 1
	{
		call SNDK_VBlank:;
		
		do
		{
			
		}
		while HVBJOY & 0x01
		call SNDK_Joypad:;
		
		idy = 0;
		if wait == 0
		{
			do
			{
				idy+=1;
			}
			while HVBJOY & 0x80
		}
		time = idy
	}
	
	
	asm "
	
	ply
	plx
	pla
	plb

	plp
	pld
	
	rti
";
}
*/
